# Database migration

Database migration can be understood as the version management of the database structure, which can effectively solve the management of the database structure among members in the team.

# Generate migration

Generate a migration file with `gen:migration`, followed by a filename argument, which is usually what the migration is going to do.

```bash
php bin/hyperf.php gen:migration create_users_table
```

The resulting migration files are located in the `migrations` folder under the root directory, and each migration file contains a timestamp so that the migration program can determine the order of the migration.

The `--table` option can be used to specify the name of the data table. The specified table name will be generated by default in the migration file.
The `--create` option is also used to specify the name of the data table, but the difference with `--table` is that the option is to generate the migration file to create the table, and `--table` is the migration file used to modify the table.

```bash
php bin/hyperf.php gen:migration create_users_table --table=users
php bin/hyperf.php gen:migration create_users_table --create=users
```

# Migration structure

The migration class will by default contain `2` methods: `up` and `down`.
The `up` method is used to add a new data table, field or index to the database, and the `down` method is the inverse of the `up` method, as opposed to the operation in `up`, so that it can be executed at the time of rollback.

```php
<?php

use Hyperf\Database\Schema\Schema;
use Hyperf\Database\Schema\Blueprint;
use Hyperf\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('true', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('true');
    }
}
```

# Run migration

Run all the unfinished migration files by executing the `migrate` command:

```bash
php bin/hyperf.php migrate
```

## Enforce migration

Some migration operations are devastating, which means that data can be lost. To prevent someone from running these commands in a production environment, the system will confirm with you before these commands run, but if you wish to ignore these acknowledgments To run the command, you can use the `--force` tag:

```bash
php bin/hyperf.php migrate --force
```

## Rollback migration

If you want to roll back the last migration, you can roll back the migration on the last side with the `migrate:rollback` command. Note that a migration may contain multiple migration files:

```bash
php bin/hyperf.php migrate:rollback
```

You can also set the number of rollback migrations by adding the `step` parameter to the `migrate:rollback` command. For example, the following command will roll back the last 5 migrations:

```bash
php bin/hyperf.php migrate:rollback --step=5
```

If you want to roll back all the migrations, you can roll back through `migrate:reset`:

```bash
php bin/hyperf.php migrate:reset
```

## Roll back and migrate

The `migrate:refresh` command not only rolls back the migration but also runs the `migrate` command, which makes it possible to efficiently rebuild some migrations:

```bash
php bin/hyperf.php migrate:refresh

// Rebuild the database structure and perform data filling
php bin/hyperf.php migrate:refresh --seed
```

Specify the number of rollbacks and rebuilds with the `--step` parameter. For example, the following command will roll back and re-execute the last 5 migrations:

```bash
php bin/hyperf.php migrate:refresh --step=5
```

## Rebuild database

The entire database can be efficiently rebuilt with the `migrate:fresh` command. This command deletes all databases before executing the `migrate` command:

```bash
php bin/hyperf.php migrate:fresh

// Rebuild the database structure and perform data filling
php bin/hyperf.php migrate:fresh --seed
```

# data table

The data table and management migration process are defined primarily in the migration file via the `Hyperf\Database\Schema\Schema` class.

## Create a data table

Create a new database table with the `create` method. The `create` method takes two arguments: the first argument is the name of the data table, and the second argument is a Closure, which receives a `Hyperf\Database that defines the new data table. \Schema\Blueprint` object:

```php
<?php

use Hyperf\Database\Schema\Schema;
use Hyperf\Database\Schema\Blueprint;
use Hyperf\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
        });
    }
}
```

You can define options for a table using the following commands on the database structure generator:

```php
// Specified table storage engine
$table->engine = 'InnoDB';
// Specify the default character set for the data table
$table->charset = 'utf8';
// Specify the default collation for the data table
$table->collation = 'utf8_unicode_ci';
// Create a temporary table
$table->temporary();
```

## Rename the data table

If you wish to rename a data table, you can use the `rename` method:

```php
Schema::rename($from, $to);
```

### Rename a data table with a foreign key

Before renaming a table, you should verify that all foreign key constraints on the table have an explicit name in the migration file, rather than having the migration program set a name by convention. Otherwise, the foreign key's constraint name will reference the old table name. .

## Delete data table

To delete an existing data table, you can use the `drop` or `dropIfExists` method:

```php
Schema::drop('users');

Schema::dropIfExists('users');
```

## Check if the data table or field exists

You can check if a data table or field exists by using the `hasTable` and `hasColumn` methods:

```php
if (Schema::hasTable('users')) {
    //
}

if (Schema::hasColumn('name', 'email')) {
    //
}
```

## Database connection options

If different migrations correspond to different database connections while managing multiple databases at the same time, then we can define different database connections in the migration file by overriding the parent class's `$connection` class property:

```php
<?php

use Hyperf\Database\Schema\Schema;
use Hyperf\Database\Schema\Blueprint;
use Hyperf\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    // 这里对应 config/autoload/databases.php 内的连接 key
    protected $connection = 'foo';
    
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->timestamps();
        });
    }
}
```

# Field

## Create field

Define the definition or change to be executed by the migration file in the `Clock' of the second parameter of the `table` or `create` method. For example, the following code defines a string field of `name`:

```php
<?php

use Hyperf\Database\Schema\Schema;
use Hyperf\Database\Schema\Blueprint;
use Hyperf\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{   
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->string('name');
        });
    }
}
```

## Available field definition methods

| Command | Description
| --- | --- |
| $table->bigIncrements('id'); | Increment ID (primary key), equivalent to "UNSIGNED BIG INTEGER" |
| $table->bigInteger('votes'); | Equivalent to BIGINT |
| $table->binary('data'); | Equivalent to BLOB |
| $table->boolean('confirmed'); | Equivalent to BOOLEAN |
| $table->char('name', 100); | Equivalent to CHAR with length |
| $table->date('created_at'); | Equivalent to DATE |
| $table->dateTime('created_at'); | Equivalent to DATETIME |
| $table->dateTimeTz('created_at'); | Equivalent to time zone DATETIME |
| $table->decimal('amount', 8, 2); | Equivalent to with precision and cardinality DECIMAL |
| $table->double('amount', 8, 2); | Equivalent to with precision and cardinality DOUBLE |
| $table->enum('level', ['easy', 'hard']); | Equivalent to ENUM |
| $table->float('amount', 8, 2); | Equivalent to with precision and cardinality FLOAT |
| $table->geometry('positions'); | Equivalent to GEOMETRY |
| $table->geometryCollection('positions'); | Equivalent to GEOMETRYCOLLECTION |
| $table->increments('id'); | Incremental ID (primary key), equivalent to "UNSIGNED INTEGER" |
| $table->integer('votes'); | Equivalent to INTEGER |
| $table->ipAddress('visitor'); | Equivalent to IP Address |
| $table->json('options'); | Equivalent to JSON |
| $table->jsonb('options'); | Equivalent to JSONB |
| $table->lineString('positions'); | Equivalent to LINESTRING |
| $table->longText('description'); | Equivalent to LONGTEXT |
| $table->macAddress('device'); | Equivalent to MAC Address |
| $table->mediumIncrements('id'); | Increment ID (primary key), equivalent to "UNSIGNED MEDIUM INTEGER" |
| $table->mediumInteger('votes'); | Equivalent to MEDIUMINT |
| $table->mediumText('description'); | Equivalent to MEDIUMTEXT |
| $table->morphs('taggable'); | Equivalent to adding incremental taggable_id and string taggable_type |
| $table->multiLineString('positions'); | Equivalent to MULTILINESTRING |
| $table->multiPoint('positions'); | Equivalent to MULTIPOINT |
| $table->multiPolygon('positions'); | Equivalent to MULTIPOLYGON |
| $table->nullableMorphs('taggable'); | Equivalent to a nullable version of morphs() field |
| $table->nullableTimestamps(); | Equivalent to a nullable version of the timestamps() field |
| $table->point('position'); | Equivalent to POINT |
| $table->polygon('positions'); | Equivalent to POLYGON |
| $table->rememberToken(); | A remember_token field equivalent to a nullable version of VARCHAR (100) |
| $table->smallIncrements('id'); | Increment ID (primary key), equivalent to "UNSIGNED SMALL INTEGER" |
| $table->smallInteger('votes'); | Equivalent to SMALLINT |
| $table->softDeletes(); | Equivalent to adding a nullable deleted_at field for soft deletes |
| $table->softDeletesTz(); | Equivalent to adding a nullable deleted_at field with a time zone for soft delete |
| $table->string('name', 100); | Equivalent to VARCHAR with length |
| $table->text('description'); | Equivalent to TEXT |
| $table->time('sunrise'); | Equivalent to TIME |
| $table->timeTz('sunrise'); | Equivalent to TIME with time zone |
| $table->timestamp('added_on'); | Equivalent to TIMESTAMP |
| $table->timestampTz('added_on'); | Equivalent to TIMESTAMP with time zone |
| $table->timestamps(); | Equivalent to nullable created_at and updated_at TIMESTAMP |
| $table->timestampsTz(); | Equivalent to a freeable time zone with created_at and updated_at TIMESTAMP |
| $table->tinyIncrements('id'); | Equivalent to auto-increment UNSIGNED TINYINT |
| $table->tinyInteger('votes'); | Equivalent to TINYINT |
| $table->unsignedBigInteger('votes'); | Equivalent to Unsigned BIGINT |
| $table->unsignedDecimal('amount', 8, 2); | Equivalent to UNSIGNED DECIMAL with precision and cardinality |
| $table->unsignedInteger('votes'); | Equivalent to Unsigned INT |
| $table->unsignedMediumInteger('votes'); | Equivalent to Unsigned MEDIUMINT |
| $table->unsignedSmallInteger('votes'); | Equivalent to Unsigned SMALLINT |
| $table->unsignedTinyInteger('votes'); | Equivalent to Unsigned TINYINT |
| $table->uuid('id'); | Equivalent to UUID |
| $table->year('birth_year'); | Equivalent to YEAR |

## Modify field

### prerequisites

Before modifying the fields, be sure to add the `doctrine/dbal` dependency to the `composer.json` file. The Doctrine DBAL library is used to determine the current state of the field and to create the SQL query needed to make the specified adjustments to the field:

```bash
composer require doctrine/dbal
```

### Update field properties

The `change` method can modify an existing field type to a new type or modify other properties.

```php
<?php

Schema::create('users', function (Blueprint $table) {
    // Modify the length of the field to 50
    $table->string('name', 50)->change();
});
```

Or modify the field to `can be null`:

```php
<?php

Schema::table('users', function (Blueprint $table) {
    // Change the length of the field to 50 and allow it to be null
    $table->string('name', 50)->nullable()->change();
});
```

> Only the following field types can be "modified"： bigInteger、 binary、 boolean、date、dateTime、dateTimeTz、decimal、integer、json、 longText、mediumText、smallInteger、string、text、time、 unsignedBigInteger、unsignedInteger and unsignedSmallInteger。

### Rename field

Fields can be renamed by the `renameColumn` method:

```php
<?php

Schema::table('users', function (Blueprint $table) {
    // Rename the field from `from` to `to`
    $table->renameColumn('from', 'to')->change();
});
```

> Field renaming of enum type is currently not supported.

### Delete field

Fields can be removed with the `dropColumn` method:

```php
<?php

Schema::table('users', function (Blueprint $table) {
    // Delete name field
    $table->dropColumn('name');
    // Delete multiple fields
    $table->dropColumn(['name', 'age']);
});
```

#### Available command alias

| Command | Description
| --- | --- |
| $table->dropRememberToken(); | Delete the remember_token field.
| $table->dropSoftDeletes(); | Delete the deleted_at field.
| $table->dropSoftDeletesTz(); | An alias for the dropSoftDeletes() method.
| $table->dropTimestamps(); | Remove the created_at and updated_at fields.
| $table->dropTimestampsTz(); | The alias of the dropTimestamps() method.

## index

### Create an index

### Unique index

Create a unique index with the `unique` method:

```php
<?php

// Create an index when defining
$table->string('name')->unique();
// Create an index after defining the field
$table->unique('name');
```

#### Composite index

```php
<?php

// Create a composite index
$table->index(['account_id', 'created_at'], 'index_account_id_and_created_at');
```

#### Define index name

The migration program automatically generates a reasonable index name, and each index method accepts an optional second parameter to specify the name of the index:

```php
<?php

// 定义唯一索引名称为 unique_name
$table->unique('name', 'unique_name');
// 定义一个复合索引名称为 index_account_id_and_created_at
$table->index(['account_id', 'created_at'], '');
```

##### Available index types

| Command | Description
| --- | --- |
| $table->primary('id'); | Add primary key
| $table->primary(['id', 'parent_id']); | Add Composite Keys
| $table->unique('email'); | Add a unique index
| $table->index('state'); | Add a normal index
| $table->spatialIndex('location'); | Add a spatial index

### Rename index

You can rename the name of an index with the `renameIndex` method:

```php
<?php

$table->renameIndex('from', 'to');
```

### Delete index

You can delete the index by the following method. By default, the migration program will automatically connect the database name, the field name of the index, and the index type as names. Examples are as follows:

| Command | Description
| --- | --- |
| $table->dropPrimary('users_id_primary'); | Remove the primary key from the users table
| $table->dropUnique('users_email_unique'); | Remove the unique index from the users table
| $table->dropIndex('geo_state_index'); | Remove the base index from the geo table
| $table->dropSpatialIndex('geo_location_spatialindex'); | Remove the spatial index from the geo table

You can also pass the array of fields to the `dropIndex` method, which the indexer will generate based on the table name, field, and key type:

```php
<?php

Schema:table('users', function (Blueprint $table) {
    $table->dropIndex(['account_id', 'created_at']);
});
```

### Foreign key constraint

We can also create foreign key constraints for the database layer via the `foreign`, `references`, and `on` methods. For example, let the `posts` table define a `user_id` field that references the `id` field of the `users` table:

```php
Schema::table('posts', function (Blueprint $table) {
    $table->unsignedInteger('user_id');

    $table->foreign('user_id')->references('id')->on('users');
});
```

You can also specify the required actions for the `on delete` and `on update` properties:

```php
$table->foreign('user_id')
      ->references('id')->on('users')
      ->onDelete('cascade');
```

You can remove foreign keys with the `dropForeign` method. The foreign key constraint is named the same way as the index, followed by the `_foreign` suffix:

```php
$table->dropForeign('posts_user_id_foreign');
```

Or pass an array of fields to have the migration program generate the name according to the agreed rules:

````php
$table->dropForeign(['user_id'']);
​```

You can use the following methods in the migration file to turn foreign key constraints on or off:

​```php
// Turn on foreign key constraint
Schema::enableForeignKeyConstraints();
// Disable foreign key constraints
Schema::disableForeignKeyConstraints();
​```
````